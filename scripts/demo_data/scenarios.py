"""
4-segment demo scenario definitions for VoiceVault 8-hour simulation.

Each scenario contains metadata, key transcripts, key summaries,
classification result, and hour summary data. Non-key minutes are
generated by cycling through key content with slight variation.
"""

from __future__ import annotations

# ---------------------------------------------------------------------------
# Segment 1: Cafe Chat with Sarah (09:00 - 09:45, 45 min)
# ---------------------------------------------------------------------------

_CAFE_KEY_TRANSCRIPTS: list[dict] = [
    {
        "minute_index": 0,
        "text": (
            "오, Sarah! 오랜만이다. 잘 지냈어? 나 아메리카노 하나 주문할게. "
            "요즘 프로젝트 때문에 정신없지 않아?"
        ),
        "confidence": 0.91,
        "language": "ko",
    },
    {
        "minute_index": 5,
        "text": (
            "프로젝트 마감일이 다음 주 금요일이라 진짜 빠듯해. "
            "프론트엔드 쪽은 거의 다 됐는데 백엔드 API 연동이 좀 남았거든."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
    {
        "minute_index": 10,
        "text": (
            "React 컴포넌트 구조를 좀 리팩토링했어. "
            "atomic design 패턴 적용했는데 재사용성이 훨씬 좋아졌어. "
            "코드 리뷰 때 팀원들 반응도 좋았고."
        ),
        "confidence": 0.92,
        "language": "ko",
    },
    {
        "minute_index": 15,
        "text": (
            "Next.js 배포는 Vercel로 할 예정이야. "
            "CI/CD 파이프라인은 GitHub Actions로 세팅했는데, "
            "PR 머지할 때 자동으로 프리뷰 배포되게 만들었어."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 22,
        "text": (
            "팀원 역할 분담을 좀 조정했어. 민수가 DB 스키마 담당하고, "
            "지현이가 인증 쪽 맡기로 했어. 나는 API 엔드포인트랑 배포 담당."
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 30,
        "text": (
            "마감일 조율이 좀 필요할 것 같아. PM한테 얘기해서 "
            "테스트 기간을 좀 더 확보하자고 할 생각이야. "
            "QA 없이 배포하면 위험하잖아."
        ),
        "confidence": 0.87,
        "language": "ko",
    },
    {
        "minute_index": 37,
        "text": (
            "다음 팀미팅은 수요일 오후 3시로 잡자. "
            "그때까지 API 문서 정리하고 Swagger 세팅 끝내놓을게. "
            "코드 리뷰도 그때 같이 하면 좋겠다."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 43,
        "text": (
            "좋아, 그럼 나 이만 도서관 가봐야겠다. 오늘 저녁에 "
            "Slack으로 진행상황 공유하자. 아, 그리고 디자인 시안 "
            "Figma에 올려뒀으니까 확인해봐!"
        ),
        "confidence": 0.91,
        "language": "ko",
    },
]

_CAFE_KEY_SUMMARIES: list[dict] = [
    {
        "minute_index": 0,
        "summary_text": "Sarah와 카페에서 만남. 인사 나누며 프로젝트 근황 이야기 시작.",
        "keywords": ["카페", "인사", "프로젝트"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 5,
        "summary_text": "프로젝트 마감일이 다음 주 금요일. 프론트엔드 거의 완료, 백엔드 API 연동 남음.",
        "keywords": ["마감일", "프론트엔드", "백엔드", "API"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 10,
        "summary_text": "React atomic design 패턴 리팩토링 완료. 코드 리뷰에서 긍정적 반응.",
        "keywords": ["React", "atomic design", "리팩토링", "코드 리뷰"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 15,
        "summary_text": "Next.js Vercel 배포 계획. GitHub Actions CI/CD로 PR 자동 프리뷰 배포 구현.",
        "keywords": ["Next.js", "Vercel", "CI/CD", "GitHub Actions", "배포"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 22,
        "summary_text": "팀원 역할 분담: 민수-DB, 지현-인증, 나-API/배포 담당.",
        "keywords": ["역할 분담", "팀", "DB", "인증"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 30,
        "summary_text": "마감일 조율 필요. PM에게 테스트 기간 확보 요청 예정. QA 중요성 논의.",
        "keywords": ["마감일", "QA", "테스트", "PM"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 37,
        "summary_text": "다음 팀미팅 수요일 오후 3시. API 문서 정리, Swagger 세팅, 코드 리뷰 예정.",
        "keywords": ["팀미팅", "API 문서", "Swagger"],
        "speakers": ["나", "Sarah"],
    },
    {
        "minute_index": 43,
        "summary_text": "미팅 마무리. Slack으로 진행상황 공유, Figma 디자인 시안 확인 요청.",
        "keywords": ["Slack", "Figma", "디자인"],
        "speakers": ["나", "Sarah"],
    },
]

# ---------------------------------------------------------------------------
# Segment 2: Lecture - Advanced AI (10:30 - 12:00, 90 min) — RAG core
# ---------------------------------------------------------------------------

_LECTURE_KEY_TRANSCRIPTS: list[dict] = [
    {
        "minute_index": 0,
        "text": (
            "안녕하세요, 오늘 Advanced AI 수업에서는 LangChain 프레임워크에 대해 "
            "알아보겠습니다. LangChain은 LLM 기반 애플리케이션을 쉽게 구축할 수 있는 "
            "오픈소스 프레임워크입니다."
        ),
        "confidence": 0.95,
        "language": "ko",
    },
    {
        "minute_index": 5,
        "text": (
            "LangChain의 핵심 구성요소는 Models, Prompts, Chains, Agents입니다. "
            "LCEL, 즉 LangChain Expression Language를 사용하면 "
            "체인을 파이프라인처럼 선언적으로 구성할 수 있습니다."
        ),
        "confidence": 0.94,
        "language": "ko",
    },
    {
        "minute_index": 12,
        "text": (
            "LCEL의 장점은 스트리밍, 배치 처리, 비동기 실행을 자동으로 지원한다는 겁니다. "
            "RunnableSequence를 통해 prompt | llm | parser 형태로 체인을 구성합니다."
        ),
        "confidence": 0.93,
        "language": "ko",
    },
    {
        "minute_index": 18,
        "text": (
            "이제 Agent 설계 패턴에 대해 살펴보겠습니다. Agent는 LLM이 도구를 선택하고 "
            "실행하는 자율적인 시스템입니다. 핵심 패턴으로 ReAct가 있습니다."
        ),
        "confidence": 0.95,
        "language": "ko",
    },
    {
        "minute_index": 24,
        "text": (
            "ReAct 패턴은 Reasoning과 Acting을 번갈아 수행합니다. "
            "LLM이 먼저 상황을 분석(Thought)하고, 어떤 도구를 쓸지 결정(Action)한 뒤, "
            "결과를 관찰(Observation)합니다. 이 루프가 반복됩니다."
        ),
        "confidence": 0.94,
        "language": "ko",
    },
    {
        "minute_index": 30,
        "text": (
            "Tool use는 Agent의 핵심 기능입니다. 검색 엔진, 계산기, 코드 실행기 등 "
            "다양한 도구를 정의하고 LLM이 필요에 따라 선택하도록 합니다. "
            "LangChain에서는 @tool 데코레이터로 쉽게 도구를 만들 수 있어요."
        ),
        "confidence": 0.93,
        "language": "ko",
    },
    {
        "minute_index": 38,
        "text": (
            "다음으로 RAG, Retrieval-Augmented Generation에 대해 설명하겠습니다. "
            "RAG는 외부 지식을 검색해서 LLM의 응답을 보강하는 기법입니다. "
            "환각(hallucination)을 줄이는 데 매우 효과적입니다."
        ),
        "confidence": 0.95,
        "language": "ko",
    },
    {
        "minute_index": 44,
        "text": (
            "RAG 아키텍처는 크게 세 단계입니다. 첫째, 문서를 청크로 분할합니다. "
            "둘째, 각 청크를 임베딩하여 벡터 스토어에 저장합니다. "
            "셋째, 쿼리 시 유사도 검색으로 관련 청크를 찾아 LLM에 전달합니다."
        ),
        "confidence": 0.94,
        "language": "ko",
    },
    {
        "minute_index": 50,
        "text": (
            "벡터 데이터베이스로는 ChromaDB, Pinecone, Weaviate 등이 있습니다. "
            "ChromaDB는 로컬에서 별도 서버 없이 바로 사용 가능해서 프로토타이핑에 좋습니다. "
            "임베딩은 sentence-transformers의 all-MiniLM-L6-v2가 경량이면서 성능이 괜찮습니다."
        ),
        "confidence": 0.93,
        "language": "ko",
    },
    {
        "minute_index": 56,
        "text": (
            "Vector embedding이란 텍스트를 고차원 벡터 공간에 매핑하는 것입니다. "
            "의미적으로 유사한 텍스트는 벡터 공간에서 가까이 위치합니다. "
            "코사인 유사도로 두 벡터의 유사성을 측정할 수 있습니다."
        ),
        "confidence": 0.94,
        "language": "ko",
    },
    {
        "minute_index": 62,
        "text": (
            "이제 Memory 시스템에 대해 알아보겠습니다. "
            "ConversationBufferMemory는 전체 대화 이력을 저장하는 가장 기본적인 방식입니다. "
            "토큰 제한이 있으므로 ConversationSummaryMemory로 요약 기반 메모리도 사용합니다."
        ),
        "confidence": 0.92,
        "language": "ko",
    },
    {
        "minute_index": 68,
        "text": (
            "Window Memory는 최근 K개의 대화만 유지하고, "
            "Entity Memory는 대화에 등장하는 엔티티를 추적합니다. "
            "실제 서비스에서는 이 메모리들을 조합해서 사용하는 경우가 많습니다."
        ),
        "confidence": 0.91,
        "language": "ko",
    },
    {
        "minute_index": 75,
        "text": (
            "LangSmith를 활용한 디버깅과 모니터링도 중요합니다. "
            "Agent의 실행 트레이스를 시각적으로 확인할 수 있고, "
            "프롬프트 성능을 비교 평가할 수 있습니다."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 80,
        "text": (
            "다음 주 실습에서는 직접 RAG 파이프라인을 구현해볼 겁니다. "
            "ChromaDB로 벡터 스토어를 구축하고, LangChain Agent와 연결해서 "
            "질의응답 시스템을 만들어보세요."
        ),
        "confidence": 0.93,
        "language": "ko",
    },
    {
        "minute_index": 87,
        "text": (
            "과제는 LangChain Agent를 활용한 RAG 질의응답 시스템 구현입니다. "
            "ReAct 패턴을 적용하고, 최소 3가지 도구를 구현해야 합니다. "
            "제출 기한은 2주 후입니다. 질문 있으면 이메일로 보내주세요."
        ),
        "confidence": 0.92,
        "language": "ko",
    },
]

_LECTURE_KEY_SUMMARIES: list[dict] = [
    {
        "minute_index": 0,
        "summary_text": (
            "Advanced AI 강의 시작. LangChain 프레임워크 소개 - "
            "LLM 기반 앱 구축 오픈소스 프레임워크."
        ),
        "keywords": ["LangChain", "프레임워크", "LLM", "오픈소스"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 5,
        "summary_text": (
            "LangChain 핵심 구성요소: Models, Prompts, Chains, Agents. "
            "LCEL로 선언적 파이프라인 구성."
        ),
        "keywords": ["LangChain", "LCEL", "Chains", "Agents", "파이프라인"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 12,
        "summary_text": (
            "LCEL 장점: 스트리밍, 배치, 비동기 자동 지원. "
            "RunnableSequence로 prompt | llm | parser 체인 구성."
        ),
        "keywords": ["LCEL", "스트리밍", "비동기", "RunnableSequence"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 18,
        "summary_text": (
            "Agent 설계 패턴 시작. Agent는 LLM이 도구를 선택/실행하는 자율 시스템. "
            "핵심 패턴: ReAct."
        ),
        "keywords": ["Agent", "설계 패턴", "ReAct", "LLM", "자율 시스템"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 24,
        "summary_text": (
            "ReAct 패턴: Reasoning + Acting 반복. "
            "Thought → Action → Observation 루프로 문제 해결."
        ),
        "keywords": ["ReAct", "Reasoning", "Acting", "Thought", "Observation"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 30,
        "summary_text": (
            "Tool use: Agent가 검색엔진, 계산기, 코드 실행기 등 도구 선택. "
            "LangChain @tool 데코레이터로 도구 정의."
        ),
        "keywords": ["Tool use", "Agent", "도구", "LangChain", "@tool"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 38,
        "summary_text": (
            "RAG(Retrieval-Augmented Generation) 설명. "
            "외부 지식 검색으로 LLM 응답 보강, 환각 감소 효과."
        ),
        "keywords": ["RAG", "Retrieval-Augmented Generation", "환각", "검색"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 44,
        "summary_text": (
            "RAG 아키텍처 3단계: 문서 청크 분할 → 벡터 스토어 임베딩 → "
            "유사도 검색 후 LLM 전달."
        ),
        "keywords": ["RAG", "청크", "벡터 스토어", "임베딩", "유사도 검색"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 50,
        "summary_text": (
            "벡터 DB 비교: ChromaDB(로컬, 무설정), Pinecone, Weaviate. "
            "임베딩 모델: all-MiniLM-L6-v2 추천."
        ),
        "keywords": ["ChromaDB", "벡터", "Pinecone", "embedding", "MiniLM"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 56,
        "summary_text": (
            "Vector embedding: 텍스트를 고차원 벡터 공간에 매핑. "
            "코사인 유사도로 의미적 유사성 측정."
        ),
        "keywords": ["vector", "embedding", "코사인 유사도", "벡터 공간"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 62,
        "summary_text": (
            "Memory 시스템: ConversationBufferMemory(전체 이력), "
            "ConversationSummaryMemory(요약 기반). 토큰 제한 관리."
        ),
        "keywords": ["Memory", "ConversationBufferMemory", "토큰"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 68,
        "summary_text": (
            "Window Memory(최근 K개), Entity Memory(엔티티 추적). "
            "실서비스에서는 메모리 조합 활용."
        ),
        "keywords": ["Window Memory", "Entity Memory", "메모리 조합"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 75,
        "summary_text": (
            "LangSmith로 Agent 실행 트레이스 디버깅. "
            "프롬프트 성능 비교 평가 가능."
        ),
        "keywords": ["LangSmith", "디버깅", "트레이스", "프롬프트"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 80,
        "summary_text": (
            "다음 주 실습: ChromaDB 벡터 스토어 구축 + LangChain Agent "
            "연결 질의응답 시스템 구현."
        ),
        "keywords": ["실습", "ChromaDB", "LangChain", "Agent", "질의응답"],
        "speakers": ["Professor Kim"],
    },
    {
        "minute_index": 87,
        "summary_text": (
            "과제: LangChain Agent + RAG 질의응답 시스템. "
            "ReAct 패턴 적용, 도구 3개 이상. 제출 2주 후."
        ),
        "keywords": ["과제", "LangChain", "Agent", "RAG", "ReAct"],
        "speakers": ["Professor Kim"],
    },
]

# ---------------------------------------------------------------------------
# Segment 3: Lunch Chat (12:00 - 13:00, 60 min)
# ---------------------------------------------------------------------------

_LUNCH_KEY_TRANSCRIPTS: list[dict] = [
    {
        "minute_index": 0,
        "text": (
            "이 식당 새로 생겼다며? 메뉴 한번 보자. "
            "나는 김치찌개 먹을래. 너는? 이번 학기 어때?"
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 7,
        "text": (
            "이번 학기 학점이 21학점이라 좀 빡세. "
            "전공 4개에 교양 하나 듣는데 과제가 엄청 많아. "
            "특히 AI 수업 과제가 매주 나와서 힘들어."
        ),
        "confidence": 0.87,
        "language": "ko",
    },
    {
        "minute_index": 14,
        "text": (
            "AI 수업 진짜 좋긴 한데 워크로드가 장난 아니야. "
            "오늘도 LangChain이랑 Agent 설계 패턴 배웠는데 "
            "과제가 RAG 시스템 구현이래."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
    {
        "minute_index": 20,
        "text": (
            "시험 준비는 어떻게 하고 있어? "
            "나는 스터디 그룹 만들어서 같이 준비하고 있어. "
            "매주 토요일 오전에 모여서 지난주 내용 복습해."
        ),
        "confidence": 0.86,
        "language": "ko",
    },
    {
        "minute_index": 28,
        "text": (
            "중간고사가 3월 말인데 범위가 엄청 넓어. "
            "교수님이 서술형 위주래서 개념을 정확히 이해해야 돼. "
            "기출문제는 학과 사무실에서 구할 수 있대."
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 35,
        "text": (
            "동아리는 요즘 어때? 나는 코딩 동아리에서 프로젝트 하나 진행 중이야. "
            "웹 서비스 만드는 건데 백엔드 담당하고 있어."
        ),
        "confidence": 0.87,
        "language": "ko",
    },
    {
        "minute_index": 44,
        "text": (
            "방학 때 여행 계획 있어? 나는 제주도 가려고 하는데 "
            "항공권이 벌써 많이 올랐더라. 일찍 예약해야 할 것 같아."
        ),
        "confidence": 0.86,
        "language": "ko",
    },
    {
        "minute_index": 55,
        "text": (
            "그래 나 오후에 도서관 가서 공부해야 해. "
            "오늘 강의에서 배운 LangGraph 복습하려고. "
            "다음에 또 밥 먹자! 시험 기간에 화이팅하자."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
]

_LUNCH_KEY_SUMMARIES: list[dict] = [
    {
        "minute_index": 0,
        "summary_text": "새 식당에서 점심. 메뉴 선택 후 학기 근황 이야기 시작.",
        "keywords": ["점심", "식당", "학기"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 7,
        "summary_text": "이번 학기 21학점. 전공 4개+교양 1개, 특히 AI 수업 과제 매주 있어 힘듦.",
        "keywords": ["학점", "전공", "AI 수업", "과제"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 14,
        "summary_text": "AI 수업 후기: 좋지만 워크로드 큼. LangChain, Agent 설계 학습, RAG 과제.",
        "keywords": ["AI", "LangChain", "Agent", "RAG", "과제"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 20,
        "summary_text": "시험 준비: 스터디 그룹 결성, 매주 토요일 오전 복습 모임.",
        "keywords": ["시험", "스터디 그룹", "복습"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 28,
        "summary_text": "중간고사 3월 말, 서술형 위주. 기출문제 학과 사무실에서 확보 가능.",
        "keywords": ["중간고사", "서술형", "기출문제"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 35,
        "summary_text": "코딩 동아리에서 웹 서비스 프로젝트 진행 중. 백엔드 담당.",
        "keywords": ["동아리", "프로젝트", "웹 서비스", "백엔드"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 44,
        "summary_text": "방학 여행 계획: 제주도 예정. 항공권 상승으로 빠른 예약 필요.",
        "keywords": ["여행", "제주도", "방학"],
        "speakers": ["나", "Friend2"],
    },
    {
        "minute_index": 55,
        "summary_text": "점심 마무리. 오후 도서관에서 LangGraph 복습 예정. 다음에 다시 만나기로.",
        "keywords": ["도서관", "LangGraph", "복습"],
        "speakers": ["나", "Friend2"],
    },
]

# ---------------------------------------------------------------------------
# Segment 4: Solo Study at Library (13:00 - 18:00, 300 min) — RAG auxiliary
# ---------------------------------------------------------------------------

_STUDY_KEY_TRANSCRIPTS: list[dict] = [
    {
        "minute_index": 0,
        "text": (
            "자, 이제 LangGraph 공부 시작하자. "
            "LangGraph는 LangChain 위에 구축된 그래프 기반 Agent 오케스트레이션 프레임워크야. "
            "StateGraph가 핵심 개념이다."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 15,
        "text": (
            "StateGraph에서 노드는 각 처리 단계를 나타내고, "
            "엣지는 노드 간 전이를 정의해. "
            "conditional_edges를 사용하면 조건부 분기가 가능하다."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
    {
        "minute_index": 30,
        "text": (
            "State 정의가 중요해. TypedDict으로 상태를 정의하고 "
            "각 노드가 상태를 읽고 수정할 수 있어. "
            "Annotated 타입으로 리듀서 함수도 지정 가능."
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 50,
        "text": (
            "그래프 컴파일 후 invoke로 실행하면 상태가 "
            "노드를 따라 흘러가면서 처리됨. "
            "stream 모드로 실행하면 각 노드의 출력을 실시간으로 볼 수 있다."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
    {
        "minute_index": 70,
        "text": (
            "Checkpoint 시스템은 LangGraph의 핵심 기능이야. "
            "SqliteSaver나 MemorySaver를 사용해서 "
            "그래프 실행 중 상태를 저장하고 복구할 수 있어."
        ),
        "confidence": 0.91,
        "language": "ko",
    },
    {
        "minute_index": 85,
        "text": (
            "체크포인트의 핵심은 thread_id 기반 분리야. "
            "같은 그래프를 여러 세션에서 독립적으로 실행할 수 있고, "
            "각 세션의 상태가 별도로 저장돼."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 100,
        "text": (
            "Persistence를 위해 PostgresSaver도 사용 가능. "
            "프로덕션 환경에서는 Redis 기반 체크포인터도 고려해야 해. "
            "recovery 시나리오: 서버 재시작 후 마지막 체크포인트에서 재개."
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 120,
        "text": (
            "Human-in-the-loop 패턴도 체크포인트로 구현 가능. "
            "interrupt_before나 interrupt_after로 특정 노드 실행 전후에 "
            "사용자 입력을 받을 수 있어."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
    {
        "minute_index": 140,
        "text": (
            "Multi-agent 오케스트레이션 패턴. "
            "Supervisor Agent가 작업을 분배하고, "
            "Worker Agent들이 각자의 역할을 수행하는 구조."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 160,
        "text": (
            "Hierarchical Agent 패턴: 상위 Agent가 하위 Agent를 관리. "
            "LangGraph의 서브그래프 기능으로 구현 가능. "
            "각 서브그래프는 독립적인 상태 공간을 가짐."
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 185,
        "text": (
            "오늘 강의에서 배운 Agent 설계 패턴을 복습하자. "
            "ReAct 패턴에서 LLM은 Thought-Action-Observation 루프를 반복하며 "
            "도구를 활용해 문제를 해결한다."
        ),
        "confidence": 0.91,
        "language": "ko",
    },
    {
        "minute_index": 200,
        "text": (
            "LangChain Agent와 LangGraph의 관계: "
            "LangChain Agent는 단일 루프 구조인 반면, "
            "LangGraph는 복잡한 멀티스텝 워크플로우를 그래프로 정의할 수 있어."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
    {
        "minute_index": 220,
        "text": (
            "강의에서 배운 RAG와 Agent를 결합하면: "
            "검색 도구로 RAG를 사용하는 Agent를 만들 수 있다. "
            "ReAct Agent가 필요시 벡터 스토어를 검색하는 구조."
        ),
        "confidence": 0.89,
        "language": "ko",
    },
    {
        "minute_index": 250,
        "text": (
            "코드 실습 중. LangGraph StateGraph를 생성하고 "
            "노드와 엣지를 추가하는 코드 작성. "
            "checkpoint를 SqliteSaver로 설정하고 테스트하는 중."
        ),
        "confidence": 0.87,
        "language": "ko",
    },
    {
        "minute_index": 280,
        "text": (
            "에러 디버깅: 노드 함수의 리턴 타입이 State와 안 맞아서 "
            "TypeError가 발생했다. dict를 반환해야 하는데 "
            "State 객체를 직접 반환하고 있었음. 수정 완료."
        ),
        "confidence": 0.88,
        "language": "ko",
    },
    {
        "minute_index": 295,
        "text": (
            "오늘 공부 정리: LangGraph 기초 개념, 체크포인트 시스템, "
            "멀티에이전트 패턴, 강의 복습(Agent 설계 패턴 + RAG). "
            "내일은 과제 시작해야지."
        ),
        "confidence": 0.90,
        "language": "ko",
    },
]

_STUDY_KEY_SUMMARIES: list[dict] = [
    {
        "minute_index": 0,
        "summary_text": (
            "LangGraph 공부 시작. LangChain 기반 그래프 Agent 오케스트레이션 프레임워크. "
            "핵심: StateGraph."
        ),
        "keywords": ["LangGraph", "StateGraph", "Agent", "오케스트레이션"],
        "speakers": [],
    },
    {
        "minute_index": 15,
        "summary_text": "StateGraph: 노드(처리 단계) + 엣지(전이). conditional_edges로 조건부 분기 구현.",
        "keywords": ["StateGraph", "노드", "엣지", "conditional_edges"],
        "speakers": [],
    },
    {
        "minute_index": 30,
        "summary_text": "State는 TypedDict으로 정의. 각 노드가 상태 읽기/수정. Annotated 리듀서 함수.",
        "keywords": ["State", "TypedDict", "Annotated", "리듀서"],
        "speakers": [],
    },
    {
        "minute_index": 50,
        "summary_text": "그래프 invoke 실행: 상태가 노드 따라 흐름. stream 모드로 실시간 출력 확인.",
        "keywords": ["invoke", "stream", "실행", "그래프"],
        "speakers": [],
    },
    {
        "minute_index": 70,
        "summary_text": (
            "Checkpoint 시스템: SqliteSaver/MemorySaver로 "
            "그래프 상태 저장/복구. LangGraph 핵심 기능."
        ),
        "keywords": ["checkpoint", "SqliteSaver", "MemorySaver", "상태 저장"],
        "speakers": [],
    },
    {
        "minute_index": 85,
        "summary_text": "thread_id 기반 세션 분리. 동일 그래프 여러 세션 독립 실행, 상태 별도 저장.",
        "keywords": ["thread_id", "세션", "독립 실행"],
        "speakers": [],
    },
    {
        "minute_index": 100,
        "summary_text": (
            "Persistence: PostgresSaver, Redis 체크포인터. "
            "프로덕션 환경 recovery 시나리오."
        ),
        "keywords": ["persistence", "PostgresSaver", "Redis", "recovery"],
        "speakers": [],
    },
    {
        "minute_index": 120,
        "summary_text": (
            "Human-in-the-loop: interrupt_before/interrupt_after로 "
            "사용자 입력 대기 구현."
        ),
        "keywords": ["human-in-the-loop", "interrupt", "사용자 입력"],
        "speakers": [],
    },
    {
        "minute_index": 140,
        "summary_text": (
            "Multi-agent 오케스트레이션: Supervisor Agent가 작업 분배, "
            "Worker Agent 역할 수행."
        ),
        "keywords": ["multi-agent", "Supervisor", "Worker", "오케스트레이션"],
        "speakers": [],
    },
    {
        "minute_index": 160,
        "summary_text": (
            "Hierarchical Agent 패턴: 상위/하위 Agent 관리. "
            "서브그래프로 구현, 독립 상태 공간."
        ),
        "keywords": ["Hierarchical Agent", "서브그래프", "상태 공간"],
        "speakers": [],
    },
    {
        "minute_index": 185,
        "summary_text": (
            "강의 복습: Agent 설계 패턴. ReAct(Thought-Action-Observation) "
            "루프, 도구 활용 문제 해결."
        ),
        "keywords": ["Agent", "설계 패턴", "ReAct", "도구", "강의 복습"],
        "speakers": [],
    },
    {
        "minute_index": 200,
        "summary_text": (
            "LangChain Agent vs LangGraph: 단일 루프 vs 멀티스텝 워크플로우 그래프."
        ),
        "keywords": ["LangChain", "LangGraph", "Agent", "워크플로우"],
        "speakers": [],
    },
    {
        "minute_index": 220,
        "summary_text": (
            "RAG + Agent 결합: 검색 도구로 RAG 활용. "
            "ReAct Agent가 벡터 스토어 검색하는 구조."
        ),
        "keywords": ["RAG", "Agent", "ReAct", "벡터 스토어", "검색"],
        "speakers": [],
    },
    {
        "minute_index": 250,
        "summary_text": (
            "코드 실습: StateGraph 생성, 노드/엣지 추가. "
            "SqliteSaver 체크포인트 설정 및 테스트."
        ),
        "keywords": ["코드", "실습", "StateGraph", "SqliteSaver"],
        "speakers": [],
    },
    {
        "minute_index": 280,
        "summary_text": "디버깅: 노드 함수 리턴 타입 오류(dict 필요). TypeError 수정 완료.",
        "keywords": ["디버깅", "TypeError", "노드 함수"],
        "speakers": [],
    },
    {
        "minute_index": 295,
        "summary_text": (
            "오늘 공부 정리: LangGraph 기초, 체크포인트, 멀티에이전트, "
            "강의 복습(Agent 설계 패턴 + RAG)."
        ),
        "keywords": ["정리", "LangGraph", "checkpoint", "Agent", "RAG"],
        "speakers": [],
    },
]

# ---------------------------------------------------------------------------
# Hour summaries for the 5-hour study session
# ---------------------------------------------------------------------------

_STUDY_HOUR_SUMMARIES: list[dict] = [
    {
        "hour_index": 0,
        "summary_text": (
            "LangGraph 기초 학습 (13:00-14:00). StateGraph, 노드, 엣지, "
            "conditional_edges 개념 학습. State를 TypedDict으로 정의하고 "
            "Annotated 리듀서 함수 활용법 정리. "
            "그래프 invoke/stream 실행 방식 이해."
        ),
        "keywords": ["LangGraph", "StateGraph", "노드", "엣지", "TypedDict"],
        "topic_segments": [
            {"topic": "LangGraph 소개", "start_minute": 0, "end_minute": 14},
            {"topic": "StateGraph 구조", "start_minute": 15, "end_minute": 29},
            {"topic": "State 정의", "start_minute": 30, "end_minute": 49},
            {"topic": "그래프 실행", "start_minute": 50, "end_minute": 59},
        ],
        "token_count": 120,
    },
    {
        "hour_index": 1,
        "summary_text": (
            "Checkpoint 시스템 심화 (14:00-15:00). SqliteSaver, MemorySaver를 "
            "활용한 상태 저장/복구. thread_id 기반 세션 분리. "
            "PostgresSaver, Redis 체크포인터로 프로덕션 persistence. "
            "Human-in-the-loop 패턴(interrupt_before/after) 학습."
        ),
        "keywords": ["checkpoint", "SqliteSaver", "thread_id", "persistence", "human-in-the-loop"],
        "topic_segments": [
            {"topic": "Checkpoint 기초", "start_minute": 60, "end_minute": 84},
            {"topic": "세션 분리", "start_minute": 85, "end_minute": 99},
            {"topic": "프로덕션 persistence", "start_minute": 100, "end_minute": 119},
        ],
        "token_count": 130,
    },
    {
        "hour_index": 2,
        "summary_text": (
            "Agent 오케스트레이션 패턴 (15:00-16:00). Human-in-the-loop 마무리. "
            "Multi-agent: Supervisor/Worker 구조. "
            "Hierarchical Agent: 상위/하위 Agent, 서브그래프 활용. "
            "독립 상태 공간으로 복잡한 워크플로우 관리."
        ),
        "keywords": ["multi-agent", "Supervisor", "Hierarchical", "서브그래프", "오케스트레이션"],
        "topic_segments": [
            {"topic": "Human-in-the-loop", "start_minute": 120, "end_minute": 139},
            {"topic": "Multi-agent 패턴", "start_minute": 140, "end_minute": 159},
            {"topic": "Hierarchical Agent", "start_minute": 160, "end_minute": 179},
        ],
        "token_count": 125,
    },
    {
        "hour_index": 3,
        "summary_text": (
            "강의 복습 + RAG 연계 (16:00-17:00). 오늘 Advanced AI 강의 복습: "
            "Agent 설계 패턴, ReAct(Thought-Action-Observation). "
            "LangChain Agent vs LangGraph 비교. "
            "RAG + Agent 결합: 검색 도구로 벡터 스토어 활용하는 ReAct Agent."
        ),
        "keywords": ["Agent 설계 패턴", "ReAct", "LangChain", "RAG", "강의 복습"],
        "topic_segments": [
            {"topic": "Agent 설계 패턴 복습", "start_minute": 180, "end_minute": 199},
            {"topic": "LangChain vs LangGraph", "start_minute": 200, "end_minute": 219},
            {"topic": "RAG + Agent 결합", "start_minute": 220, "end_minute": 239},
        ],
        "token_count": 135,
    },
    {
        "hour_index": 4,
        "summary_text": (
            "코드 실습 + 정리 (17:00-18:00). StateGraph 생성, 노드/엣지 코드 작성. "
            "SqliteSaver 체크포인트 설정 테스트. "
            "디버깅: 노드 함수 리턴 타입 오류 해결. "
            "하루 학습 정리: LangGraph 기초, 체크포인트, 멀티에이전트, 강의 복습."
        ),
        "keywords": ["코드 실습", "StateGraph", "디버깅", "정리"],
        "topic_segments": [
            {"topic": "코드 실습", "start_minute": 240, "end_minute": 279},
            {"topic": "디버깅", "start_minute": 280, "end_minute": 294},
            {"topic": "정리", "start_minute": 295, "end_minute": 299},
        ],
        "token_count": 130,
    },
]

# ---------------------------------------------------------------------------
# Public scenarios list
# ---------------------------------------------------------------------------

SCENARIOS: list[dict] = [
    {
        "title": "[DEMO] Sarah - Project Meeting",
        "template_name": "conversation",
        "started_at": "2026-02-10T09:00:00",
        "ended_at": "2026-02-10T09:45:00",
        "total_minutes": 45,
        "classification_confidence": 0.88,
        "result_json": {
            "summary": (
                "카페에서 Sarah와 프로젝트 진행상황 논의. "
                "프론트엔드(React atomic design) 완료, 백엔드 API 연동 진행 중. "
                "Next.js Vercel 배포 + GitHub Actions CI/CD 구축. "
                "팀원 역할 재분배(민수-DB, 지현-인증). "
                "마감일 조율 및 QA 기간 확보 논의."
            ),
            "topics": [
                "프로젝트 마감일 (다음 주 금요일)",
                "React atomic design 리팩토링",
                "Next.js Vercel 배포 + CI/CD",
                "팀원 역할 분담",
                "코드 리뷰 및 QA",
                "Figma 디자인 시안",
            ],
            "participants": ["나", "Sarah"],
            "mood": "productive, friendly",
        },
        "key_transcripts": _CAFE_KEY_TRANSCRIPTS,
        "key_summaries": _CAFE_KEY_SUMMARIES,
        "hour_summaries": [],
    },
    {
        "title": "[DEMO] Advanced AI - LangChain & Agents",
        "template_name": "lecture",
        "started_at": "2026-02-10T10:30:00",
        "ended_at": "2026-02-10T12:00:00",
        "total_minutes": 90,
        "classification_confidence": 0.95,
        "result_json": {
            "summary": (
                "Advanced AI 강의: LangChain 프레임워크 전반. "
                "LCEL 파이프라인, Agent 설계 패턴(ReAct), Tool use, "
                "RAG 아키텍처(ChromaDB, embedding), Memory 시스템, "
                "LangSmith 디버깅. 과제: RAG+Agent 질의응답 시스템 구현."
            ),
            "key_concepts": [
                "LangChain 프레임워크 (Models, Prompts, Chains, Agents)",
                "LCEL (LangChain Expression Language) 선언적 파이프라인",
                "Agent 설계 패턴: ReAct (Thought → Action → Observation)",
                "Tool use: @tool 데코레이터로 Agent 도구 정의",
                "RAG (Retrieval-Augmented Generation): 외부 지식 검색 보강",
                "ChromaDB 벡터 스토어 + all-MiniLM-L6-v2 임베딩",
                "Vector embedding: 코사인 유사도 기반 의미 검색",
                "Memory 시스템: Buffer, Summary, Window, Entity Memory",
            ],
            "examples": [
                "RunnableSequence: prompt | llm | parser 체인 구성 예시",
                "ReAct Agent가 검색엔진 Tool을 사용하는 예시",
                "ChromaDB로 문서 임베딩 후 유사도 검색 예시",
            ],
            "questions": [
                "과제: LangChain Agent + RAG 질의응답 시스템 (ReAct 패턴, 도구 3개 이상, 2주 후 제출)",
                "다음 주 실습: ChromaDB 벡터 스토어 + LangChain Agent 연결",
            ],
        },
        "key_transcripts": _LECTURE_KEY_TRANSCRIPTS,
        "key_summaries": _LECTURE_KEY_SUMMARIES,
        "hour_summaries": [],
    },
    {
        "title": "[DEMO] Friend2 - Academic Check-in",
        "template_name": "conversation",
        "started_at": "2026-02-10T12:00:00",
        "ended_at": "2026-02-10T13:00:00",
        "total_minutes": 60,
        "classification_confidence": 0.85,
        "result_json": {
            "summary": (
                "점심 식사하며 학기 근황 공유. "
                "21학점 수강, AI 수업 워크로드 높음. "
                "시험 준비 스터디 그룹 운영. "
                "코딩 동아리 프로젝트, 방학 여행 계획."
            ),
            "topics": [
                "이번 학기 근황 (21학점)",
                "AI 수업 후기 및 과제",
                "시험 준비 전략 (스터디 그룹)",
                "코딩 동아리 프로젝트",
                "방학 여행 계획 (제주도)",
            ],
            "participants": ["나", "Friend2"],
            "mood": "casual, friendly",
        },
        "key_transcripts": _LUNCH_KEY_TRANSCRIPTS,
        "key_summaries": _LUNCH_KEY_SUMMARIES,
        "hour_summaries": [],
    },
    {
        "title": "[DEMO] Study Session - LangGraph Deep Dive",
        "template_name": "memo",
        "started_at": "2026-02-10T13:00:00",
        "ended_at": "2026-02-10T18:00:00",
        "total_minutes": 300,
        "classification_confidence": 0.92,
        "result_json": {
            "summary": (
                "도서관에서 5시간 LangGraph 심화 학습. "
                "StateGraph 기초, 체크포인트 시스템(SqliteSaver), "
                "멀티에이전트 오케스트레이션 패턴, "
                "오늘 강의 복습(Agent 설계 패턴 + RAG 연계). "
                "코드 실습 및 디버깅."
            ),
            "key_points": [
                "LangGraph: StateGraph 기반 Agent 오케스트레이션 프레임워크",
                "StateGraph: 노드(처리 단계) + 엣지(전이) + conditional_edges",
                "State: TypedDict 정의, Annotated 리듀서 함수",
                "Checkpoint: SqliteSaver/MemorySaver로 상태 저장/복구",
                "thread_id 기반 세션 분리, PostgresSaver/Redis 프로덕션 옵션",
                "Human-in-the-loop: interrupt_before/after 패턴",
                "Multi-agent: Supervisor → Worker 구조",
                "Hierarchical Agent: 서브그래프로 상위/하위 Agent 관리",
                "강의 복습: ReAct 패턴, RAG + Agent 결합",
                "코드 실습: StateGraph 생성, 체크포인트 테스트, TypeError 디버깅",
            ],
            "references": [
                "LangGraph 공식 문서",
                "오늘 Advanced AI 강의 노트 (LangChain & Agents)",
                "LangChain Agent 관련 GitHub 예제",
            ],
        },
        "key_transcripts": _STUDY_KEY_TRANSCRIPTS,
        "key_summaries": _STUDY_KEY_SUMMARIES,
        "hour_summaries": _STUDY_HOUR_SUMMARIES,
    },
]


def generate_all_transcripts(scenario: dict) -> list[dict]:
    """Generate transcript entries for every minute, cycling key transcripts.

    Key minutes use their exact text. Non-key minutes reuse the closest
    preceding key minute's text with a prefix indicating the minute.

    Args:
        scenario: A scenario dict from SCENARIOS.

    Returns:
        List of transcript dicts for minute_index 0..total_minutes-1.
    """
    total = scenario["total_minutes"]
    keys = scenario["key_transcripts"]
    if not keys:
        return []

    # Build lookup: minute_index -> transcript dict
    key_map: dict[int, dict] = {t["minute_index"]: t for t in keys}
    key_indices = sorted(key_map.keys())

    result: list[dict] = []
    for m in range(total):
        if m in key_map:
            result.append(key_map[m])
        else:
            # Find the closest preceding key minute
            closest = key_indices[0]
            for ki in key_indices:
                if ki <= m:
                    closest = ki
                else:
                    break
            base = key_map[closest]
            result.append({
                "minute_index": m,
                "text": base["text"],
                "confidence": round(base["confidence"] - 0.02, 2),
                "language": base["language"],
            })

    return result


def generate_all_summaries(scenario: dict) -> list[dict]:
    """Generate summary entries for every minute, cycling key summaries.

    Key minutes use their exact summary. Non-key minutes reuse the closest
    preceding key minute's summary.

    Args:
        scenario: A scenario dict from SCENARIOS.

    Returns:
        List of summary dicts for minute_index 0..total_minutes-1.
    """
    total = scenario["total_minutes"]
    keys = scenario["key_summaries"]
    if not keys:
        return []

    key_map: dict[int, dict] = {s["minute_index"]: s for s in keys}
    key_indices = sorted(key_map.keys())

    result: list[dict] = []
    for m in range(total):
        if m in key_map:
            result.append(key_map[m])
        else:
            closest = key_indices[0]
            for ki in key_indices:
                if ki <= m:
                    closest = ki
                else:
                    break
            base = key_map[closest]
            result.append({
                "minute_index": m,
                "summary_text": base["summary_text"],
                "keywords": base["keywords"],
                "speakers": base["speakers"],
            })

    return result
